// Copyright: 2015 Mohit Saini
// Author: Mohit Saini (mohitsaini1196@gmail.com)

#include <sstream>
#include "aparse/error.hpp"

namespace aparse {

// Run this python code for generating case-switch code. Add more enum here and
// regenerate it.
//
// a = 'SUCCESS, INTERNAL_BUG, LEXER_BUILDER_ERROR, LEXER_BUILDER_ERROR_MUST_HAVE_NON_ZERO_RULES, LEXER_ERROR, LEXER_ERROR_INVALID_TOKENS, LEXER_ERROR_INCOMPLETE_TOKENS, INTERNAL_GRAMMAR_REGEX_LABEL_MUST_BE_ZERO, GRAMMAR_INVALID_USE_OF_BRANCHING_ALPHABET, INTERNAL_GRAMMAR_MUST_HAVE_POSITIVE_ALPHABET_SIZE, INTERNAL_GRAMMAR_MUST_HAVE_NON_ZERO_RULES, INTERNAL_GRAMMAR_INVALID_NON_TERMINAL, INTERNAL_GRAMMAR_INVALID_MAIN_NON_TERMINAL, INTERNAL_GRAMMAR_UNDEFINED_NON_TERMINAL, INTERNAL_GRAMMAR_INVALID_BRANCHING_ALPHABETS, GRAMMAR_REPEATED_BRANCHING_ALPHABETS, INTERNAL_GRAMMAR_NON_ENCLOSED_CYCLIC_DEPENDENCY, GRAMMAR_DIRECT_COPY_RULES_ARE_NOT_SUPPORTED_YET, GRAMMAR_REPEATED_NON_TERMINALS_ARE_NOT_SUPPORTED_YET, PARSING_ERROR_INCOMPLETE_TOKENS, PARSING_ERROR_INVALID_TOKENS, PARSER_BUILDER_ERROR_INVALID_RULE, INVALID_RULE_ACTION_TYPE, INVALID_LEXER_RUN_ACTION_TYPE'; print("\n".join("case "+i.strip()+":\n  return \""+i.strip()+"\";" for i in a.split(",")))  #  // NOLINT
string Error::ErrorCodeString(Error::ErrorStatus input) {
  switch (input) {
    case SUCCESS:
      return "SUCCESS";
    case INTERNAL_BUG:
      return "INTERNAL_BUG";
    case LEXER_BUILDER_ERROR:
      return "LEXER_BUILDER_ERROR";
    case LEXER_BUILDER_ERROR_MUST_HAVE_NON_ZERO_RULES:
      return "LEXER_BUILDER_ERROR_MUST_HAVE_NON_ZERO_RULES";
    case LEXER_ERROR:
      return "LEXER_ERROR";
    case LEXER_ERROR_INVALID_TOKENS:
      return "LEXER_ERROR_INVALID_TOKENS";
    case LEXER_ERROR_INCOMPLETE_TOKENS:
      return "LEXER_ERROR_INCOMPLETE_TOKENS";
    case INTERNAL_GRAMMAR_REGEX_LABEL_MUST_BE_ZERO:
      return "INTERNAL_GRAMMAR_REGEX_LABEL_MUST_BE_ZERO";
    case GRAMMAR_INVALID_USE_OF_BRANCHING_ALPHABET:
      return "GRAMMAR_INVALID_USE_OF_BRANCHING_ALPHABET";
    case INTERNAL_GRAMMAR_MUST_HAVE_POSITIVE_ALPHABET_SIZE:
      return "INTERNAL_GRAMMAR_MUST_HAVE_POSITIVE_ALPHABET_SIZE";
    case INTERNAL_GRAMMAR_MUST_HAVE_NON_ZERO_RULES:
      return "INTERNAL_GRAMMAR_MUST_HAVE_NON_ZERO_RULES";
    case INTERNAL_GRAMMAR_INVALID_NON_TERMINAL:
      return "INTERNAL_GRAMMAR_INVALID_NON_TERMINAL";
    case INTERNAL_GRAMMAR_INVALID_MAIN_NON_TERMINAL:
      return "INTERNAL_GRAMMAR_INVALID_MAIN_NON_TERMINAL";
    case INTERNAL_GRAMMAR_UNDEFINED_NON_TERMINAL:
      return "INTERNAL_GRAMMAR_UNDEFINED_NON_TERMINAL";
    case INTERNAL_GRAMMAR_INVALID_BRANCHING_ALPHABETS:
      return "INTERNAL_GRAMMAR_INVALID_BRANCHING_ALPHABETS";
    case GRAMMAR_REPEATED_BRANCHING_ALPHABETS:
      return "GRAMMAR_REPEATED_BRANCHING_ALPHABETS";
    case INTERNAL_GRAMMAR_NON_ENCLOSED_CYCLIC_DEPENDENCY:
      return "INTERNAL_GRAMMAR_NON_ENCLOSED_CYCLIC_DEPENDENCY";
    case GRAMMAR_DIRECT_COPY_RULES_ARE_NOT_SUPPORTED_YET:
      return "GRAMMAR_DIRECT_COPY_RULES_ARE_NOT_SUPPORTED_YET";
    case GRAMMAR_REPEATED_NON_TERMINALS_ARE_NOT_SUPPORTED_YET:
      return "GRAMMAR_REPEATED_NON_TERMINALS_ARE_NOT_SUPPORTED_YET";
    case PARSING_ERROR_INCOMPLETE_TOKENS:
      return "PARSING_ERROR_INCOMPLETE_TOKENS";
    case PARSING_ERROR_INVALID_TOKENS:
      return "PARSING_ERROR_INVALID_TOKENS";
    case LEXER_BUILDER_ERROR_INVALID_REGEX:
      return "LEXER_BUILDER_ERROR_INVALID_REGEX";
    case PARSER_BUILDER_ERROR_INVALID_RULE:
      return "PARSER_BUILDER_ERROR_INVALID_RULE";
    case INVALID_RULE_ACTION_TYPE:
      return "INVALID_RULE_ACTION_TYPE";
    case INVALID_LEXER_RUN_ACTION_TYPE:
      return "INVALID_LEXER_RUN_ACTION_TYPE";
    default: assert(false);
  }
  return "";
}

string Error::ErrorCodeMeaning(Error::ErrorStatus input) {
  switch (input) {
    case SUCCESS: return "SUCCESS";
    default: assert(false);
  }
  return "";
}

Error& Error::operator()() {
  std::ostringstream oss;
  oss << ErrorCodeString(status) << ": ";
  oss << string_value << "\n";
  switch (status) {
    case LEXER_ERROR_INCOMPLETE_TOKENS:
    case LEXER_ERROR_INVALID_TOKENS:
    case LEXER_BUILDER_ERROR_INVALID_REGEX:
      oss << " at " << error_position.first << ":" << error_position.second;
      break;
    case PARSING_ERROR_INVALID_TOKENS:
    case PARSER_BUILDER_ERROR_INVALID_RULE:
      oss << " at " << error_position.first << ":" << error_position.second;
      break;
    default: break;
  }
  error_message = oss.str();
  return *this;
}

}  // namespace aparse
